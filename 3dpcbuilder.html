<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Build Your Own PC - 3D Configurator</title>
    <!-- Load Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Load Three.js for 3D rendering -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- Load OrbitControls for camera interaction -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <!-- Use Inter font family -->
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@100..900&display=swap');
        body {
            font-family: 'Inter', sans-serif;
            background-color: #0d0d0d;
            color: #fff;
            overflow: hidden; /* Prevent scrolling */
        }
        #scene-container {
            width: 100%;
            height: 100%;
            display: block;
        }
        /* Styling for the component selection buttons */
        .component-btn {
            @apply flex items-center justify-between p-4 rounded-lg cursor-pointer transition duration-300;
            @apply bg-neutral-800 hover:bg-neutral-700;
        }
        .component-btn.selected {
            @apply border-2 border-indigo-500 bg-indigo-900/50;
        }
    </style>
</head>
<body>

    <!-- Main Application Container -->
    <div class="flex h-screen">
        
        <!-- Sidebar: Component Selection Panel -->
        <div class="w-full lg:w-96 p-6 bg-[#161616] flex flex-col overflow-y-auto">
            <h1 class="text-3xl font-extrabold text-white mb-6">Build Your PC</h1>
            <p class="text-gray-400 mb-8">Select a component to see it insert into the 3D model.</p>
            
            <div id="component-list" class="space-y-4">
                <!-- Processor Button -->
                <div class="component-btn" data-component="processor" data-color="#FF3366">
                    <div>
                        <span class="font-semibold text-lg">Processor</span>
                        <p class="text-sm text-gray-400">AMD Ryzen 7 7800X3D</p>
                    </div>
                    <span id="processor-status" class="text-xs font-bold text-red-400">ADD</span>
                </div>

                <!-- RAM Button -->
                <div class="component-btn" data-component="ram" data-color="#33FFCC">
                    <div>
                        <span class="font-semibold text-lg">RAM (Memory)</span>
                        <p class="text-sm text-gray-400">32GB DDR5 6000MHz</p>
                    </div>
                    <span id="ram-status" class="text-xs font-bold text-red-400">ADD</span>
                </div>

                <!-- GPU Button -->
                <div class="component-btn" data-component="gpu" data-color="#3366FF">
                    <div>
                        <span class="font-semibold text-lg">Graphics Card</span>
                        <p class="text-sm text-gray-400">NVIDIA GeForce RTX 4080</p>
                    </div>
                    <span id="gpu-status" class="text-xs font-bold text-red-400">ADD</span>
                </div>
                
                <!-- Storage Button -->
                <div class="component-btn" data-component="storage" data-color="#FFFF33">
                    <div>
                        <span class="font-semibold text-lg">Storage (SSD)</span>
                        <p class="text-sm text-gray-400">2TB NVMe M.2</p>
                    </div>
                    <span id="storage-status" class="text-xs font-bold text-red-400">ADD</span>
                </div>
            </div>
            
            <!-- Summary and Checkout -->
            <div class="mt-auto pt-6 border-t border-neutral-700/50">
                <div class="flex justify-between items-center mb-4">
                    <span class="text-gray-400">Estimated Total:</span>
                    <span id="total-price" class="text-2xl font-bold text-green-400">$2,899</span>
                </div>
                <button class="w-full py-3 bg-indigo-600 text-white font-semibold rounded-lg hover:bg-indigo-700 transition duration-300">
                    Review & Checkout
                </button>
            </div>

        </div>

        <!-- Main Content: 3D Scene Container -->
        <div id="scene-container" class="flex-grow">
            <!-- Canvas will be injected here by Three.js -->
        </div>

    </div>

    <script>
        // Global variables for the 3D scene
        let scene, camera, renderer, controls;
        const componentState = {};

        // Configuration for component insertion
        const componentPositions = {
            // Placeholder coordinates relative to the Motherboard center (0, 0, 0)
            processor: { x: 0, y: 0, z: 0.1, color: '#FF3366', dims: [0.5, 0.05, 0.5] },
            ram: { x: 0.8, y: 0, z: 0.1, color: '#33FFCC', dims: [0.1, 0.05, 1.2] },
            gpu: { x: -0.6, y: -0.4, z: 0.1, color: '#3366FF', dims: [0.3, 0.05, 2.5] },
            storage: { x: 1.5, y: -0.6, z: 0.1, color: '#FFFF33', dims: [0.5, 0.05, 0.5] }
        };

        // Utility function for exponential backoff on fetch/API calls (not used for Three.js, but good practice)
        const fetchWithBackoff = async (url, options, maxRetries = 5) => {
            let delay = 1000;
            for (let i = 0; i < maxRetries; i++) {
                try {
                    const response = await fetch(url, options);
                    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
                    return response;
                } catch (error) {
                    if (i === maxRetries - 1) throw error;
                    console.warn(`Request failed, retrying in ${delay / 1000}s...`, error.message);
                    await new Promise(resolve => setTimeout(resolve, delay));
                    delay *= 2; // Exponential backoff
                }
            }
        };

        function init3DScene() {
            const container = document.getElementById('scene-container');
            const width = container.clientWidth;
            const height = container.clientHeight;

            // 1. Scene setup
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x0d0d0d); // Dark background

            // 2. Camera setup
            camera = new THREE.PerspectiveCamera(75, width / height, 0.1, 1000);
            camera.position.set(0, 2.5, 3.5);

            // 3. Renderer setup
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(width, height);
            container.appendChild(renderer.domElement);

            // Handle window resizing
            window.addEventListener('resize', onWindowResize, false);

            // 4. Lighting
            const ambientLight = new THREE.AmbientLight(0x404040, 3); // soft white light
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 2);
            directionalLight.position.set(5, 5, 5).normalize();
            scene.add(directionalLight);

            // 5. Controls (Allow user to rotate the view)
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true; // smooth rotation
            controls.dampingFactor = 0.05;
            controls.screenSpacePanning = false;
            controls.minDistance = 2;
            controls.maxDistance = 10;
            controls.maxPolarAngle = Math.PI / 2; // Limit vertical rotation

            // 6. Create base models (Motherboard and Case placeholder)
            createBasePC();

            // 7. Start the animation loop
            animate();
        }

        function createBasePC() {
            // Motherboard Placeholder (a large flat plane)
            const mbGeometry = new THREE.BoxGeometry(3, 2, 0.1);
            const mbMaterial = new THREE.MeshPhongMaterial({ color: 0x222222, shininess: 50 });
            const motherboard = new THREE.Mesh(mbGeometry, mbMaterial);
            motherboard.rotation.x = -Math.PI / 2; // Lay it flat
            motherboard.position.y = -0.5;
            scene.add(motherboard);

            // Case Placeholder (a transparent box outline)
            const caseGeometry = new THREE.BoxGeometry(4, 5, 4);
            const caseMaterial = new THREE.MeshBasicMaterial({ color: 0x1a1a1a, wireframe: true });
            const pcCase = new THREE.Mesh(caseGeometry, caseMaterial);
            pcCase.position.y = 1.5;
            scene.add(pcCase);
            
            // Add slots for insertion visualization (optional: makes it clearer where things go)
            Object.keys(componentPositions).forEach(key => {
                const pos = componentPositions[key];
                const slotGeometry = new THREE.BoxGeometry(pos.dims[0] * 0.9, 0.01, pos.dims[2] * 0.9);
                const slotMaterial = new THREE.MeshBasicMaterial({ color: 0x000000, transparent: true, opacity: 0.5 });
                const slot = new THREE.Mesh(slotGeometry, slotMaterial);
                
                // Position slots relative to Motherboard
                slot.position.set(pos.x, motherboard.position.y + 0.06, pos.z); 
                slot.rotation.x = -Math.PI / 2; // Keep it flat
                slot.name = `${key}Slot`;
                scene.add(slot);
            });
        }

        function insertComponent(componentName, color) {
            if (componentState[componentName]) {
                console.log(`${componentName} already inserted.`);
                return; // Component already inserted
            }

            const config = componentPositions[componentName];
            if (!config) return;

            // 1. Create the component geometry
            const geometry = new THREE.BoxGeometry(config.dims[0], config.dims[1], config.dims[2]);
            const material = new THREE.MeshPhongMaterial({ color: color, shininess: 100 });
            const componentMesh = new THREE.Mesh(geometry, material);
            componentMesh.name = componentName;

            // The component needs to be rotated to match the motherboard's angle, and then moved to the motherboard.
            componentMesh.rotation.x = -Math.PI / 2;

            // 2. Define Start and End Points for the animation
            // Start (Out of view, above the PC case)
            const startPosition = new THREE.Vector3(config.x + 3, 4, config.z);
            // End (Target slot on the motherboard)
            const endPosition = new THREE.Vector3(config.x, -0.44, config.z);

            componentMesh.position.copy(startPosition);
            scene.add(componentMesh);

            // 3. Animation using GSAP (via global window.gsap if loaded, but Three.js uses its own vector/tweening system often)
            // We can use a simple manual animation loop or GSAP if we included it, but for simplicity, we'll use a smooth step function in the render loop or a simple linear transition.
            
            // For a dramatic effect, let's use THREE's Clock and a simple interpolation.
            const duration = 1.5; // seconds
            const startTime = Date.now() / 1000;

            function animateInsertion() {
                const elapsedTime = Date.now() / 1000 - startTime;
                const t = Math.min(1, elapsedTime / duration); // t goes from 0 to 1

                // Use smooth step for a gentle start/end
                const smoothedT = t * t * (3 - 2 * t); 

                // Interpolate position
                componentMesh.position.lerpVectors(startPosition, endPosition, smoothedT);

                if (t < 1) {
                    requestAnimationFrame(animateInsertion);
                } else {
                    // Animation complete
                    componentState[componentName] = componentMesh;
                    // Update UI status
                    const statusEl = document.getElementById(`${componentName}-status`);
                    if (statusEl) {
                        statusEl.textContent = 'INSTALLED';
                        statusEl.classList.remove('text-red-400');
                        statusEl.classList.add('text-green-400');
                    }
                }
            }
            animateInsertion();
        }

        function animate() {
            requestAnimationFrame(animate);
            controls.update(); // only required if controls.enableDamping is set to true
            renderer.render(scene, camera);
        }

        function onWindowResize() {
            const container = document.getElementById('scene-container');
            const width = container.clientWidth;
            const height = container.clientHeight;

            camera.aspect = width / height;
            camera.updateProjectionMatrix();
            renderer.setSize(width, height);
        }


        // --- UI Initialization and Event Handlers ---
        
        document.addEventListener('DOMContentLoaded', () => {
            init3DScene();

            const componentList = document.getElementById('component-list');
            const componentButtons = componentList.querySelectorAll('.component-btn');

            componentButtons.forEach(button => {
                button.addEventListener('click', (e) => {
                    const component = button.getAttribute('data-component');
                    const color = button.getAttribute('data-color');
                    
                    // Clear previous selection visually (optional)
                    componentButtons.forEach(btn => btn.classList.remove('selected'));
                    
                    // Highlight current selection
                    button.classList.add('selected');

                    // Trigger the 3D insertion effect
                    insertComponent(component, color);
                });
            });

        });

        // Ensure the animation loop starts
        window.onload = function () {
            // The scene is initialized inside DOMContentLoaded, but we ensure rendering begins here if needed.
        }

    </script>

</body>
</html>